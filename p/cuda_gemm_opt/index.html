<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="CUDA 矩阵乘法的一步步优化指南"><title>CUDA GEMM 优化</title>
<link rel=canonical href=https://georgelyu.github.io/p/cuda_gemm_opt/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="CUDA GEMM 优化"><meta property='og:description' content="CUDA 矩阵乘法的一步步优化指南"><meta property='og:url' content='https://georgelyu.github.io/p/cuda_gemm_opt/'><meta property='og:site_name' content='吕超阳的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2025-02-22T21:32:50+08:00'><meta property='article:modified_time' content='2025-02-22T21:32:50+08:00'><meta name=twitter:title content="CUDA GEMM 优化"><meta name=twitter:description content="CUDA 矩阵乘法的一步步优化指南"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_c68a00bbf16dac8.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>吕超阳的博客</a></h1><h2 class=site-description>写点想写的东西。</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>存档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#第一版实现naive>第一版实现：naive</a></li><li><a href=#第二版实现block-tiling>第二版实现：block tiling</a></li><li><a href=#第三版实现thread-coarsening>第三版实现：thread coarsening</a><ol><li><a href=#分析stride-调参>分析：stride 调参</a></li></ol></li><li><a href=#第四版实现2d-thread-coarsening>第四版实现：2D thread coarsening</a></li><li><a href=#第五版实现vectorized-memory-access>第五版实现：vectorized memory access</a></li><li><a href=#第六版实现warp-tiling>第六版实现：warp tiling</a></li><li><a href=#第七版实现函数化封装>第七版实现：函数化封装</a></li><li><a href=#第八版实现double-buffer>第八版实现：double buffer</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/cuda/>CUDA</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/cuda_gemm_opt/>CUDA GEMM 优化</a></h2><h3 class=article-subtitle>CUDA 矩阵乘法的一步步优化指南</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025 年 2 月 22 日</time></div></footer></div></header><section class=article-content><p>因为最近读完了《Programming Massively Parallel Processors: A Hands-on Approach (4th Edition)》这本书（下面简称 PMPP），非常想结合书中的内容实操一下。</p><p>所以我结合了 <a class=link href=https://zhuanlan.zhihu.com/p/478846788 target=_blank rel=noopener>cuda 入门的正确姿势：how-to-optimize-gemm</a> 和 <a class=link href=https://siboehm.com/articles/22/CUDA-MMM target=_blank rel=noopener>How to Optimize a CUDA Matmul Kernel for cuBLAS-like Performance: a Worklog</a> 这两篇非常好的文章，自己结合 PMPP 中的经验写了一版代码，同时记录一下学习的过程。</p><h2 id=第一版实现naive>第一版实现：naive</h2><p>第一版基本是最 naive 的实现。如果这个矩阵乘法是 $A \times B = C$，$A$、$B$、$C$ 三个矩阵的维度分别为 $m \times k$、$k \times n$、$m \times n$，则下面的 kernel 中每个线程对应矩阵 $C$ 中的一个元素，所以每个线程会进行 $k$ 次浮点数乘加。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#define A(i, j) d_A[(i) * k + (j)]</span>
</span></span><span class=line><span class=cl><span class=c1>#define B(i, j) d_B[(i) * n + (j)]</span>
</span></span><span class=line><span class=cl><span class=c1>#define C(i, j) d_C[(i) * n + (j)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>Naive</span> <span class=n>version</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=n>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=ne>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=ne>int</span> <span class=n>m</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>,</span> <span class=ne>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>_m</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=o>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>blockDim</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>threadIdx</span><span class=o>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>_n</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=o>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>blockDim</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>threadIdx</span><span class=o>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>_m</span> <span class=o>&lt;</span> <span class=n>m</span> <span class=o>&amp;&amp;</span> <span class=n>_n</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Value_t</span> <span class=n>c_value</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>_k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>_k</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>;</span> <span class=o>++</span><span class=n>_k</span><span class=p>)</span> <span class=n>c_value</span> <span class=o>+=</span> <span class=n>A</span><span class=p>(</span><span class=n>_m</span><span class=p>,</span> <span class=n>_k</span><span class=p>)</span> <span class=o>*</span> <span class=n>B</span><span class=p>(</span><span class=n>_k</span><span class=p>,</span> <span class=n>_n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>C</span><span class=p>(</span><span class=n>_m</span><span class=p>,</span> <span class=n>_n</span><span class=p>)</span> <span class=o>=</span> <span class=n>c_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>MyMatMul</span><span class=p>(</span><span class=ne>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=ne>int</span> <span class=n>m</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>,</span> <span class=ne>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>constexpr</span> <span class=ne>int</span> <span class=n>kBlockDim</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>block</span><span class=p>(</span><span class=n>kBlockDim</span><span class=p>,</span> <span class=n>kBlockDim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>grid</span><span class=p>((</span><span class=n>n</span> <span class=o>+</span> <span class=n>kBlockDim</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockDim</span><span class=p>,</span> <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>kBlockDim</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockDim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MyMatMulKernel</span><span class=o>&lt;&lt;&lt;</span><span class=n>grid</span><span class=p>,</span> <span class=n>block</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>d_C</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>因为是第一版实现，所以没有在乎任何的参数设置（如 block 大小等）。同时说一下下面所有的测试中都使用 <code>float</code> 类型计算，并用我自己的 NVIDIA RTX 3090 来测试。这一版的性能可以达到大约 2.2 TFLOPS（根据参数该卡的理论性能为 35.58 TFLOPS）。</p><p>并且注意到，这里的写法已经进行了 global memory 的 coalesced access。</p><h2 id=第二版实现block-tiling>第二版实现：block tiling</h2><p>第二版使用了 PMPP 第 5.4 和 5.5 节中提到的 tiling 方法，即将会被重复使用的数据放置在 block 的 shared memory 中，这样减少了 global memory 的重复传输。这个思想也是对应原 repo 中的 <a class=link href=https://github.com/tpoisonooo/how-to-optimize-gemm/blob/master/cuda/MMult_cuda_3.cu target=_blank rel=noopener>MMult_cuda_3.cu</a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#define A(i, j) d_A[(i) * k + (j)]</span>
</span></span><span class=line><span class=cl><span class=c1>#define B(i, j) d_B[(i) * n + (j)]</span>
</span></span><span class=line><span class=cl><span class=c1>#define C(i, j) d_C[(i) * n + (j)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>Tiled</span> <span class=n>version</span>
</span></span><span class=line><span class=cl><span class=n>template</span> <span class=o>&lt;</span><span class=ne>int</span> <span class=n>kTileWidth</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=n>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=ne>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=ne>int</span> <span class=n>m</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>,</span> <span class=ne>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads</span><span class=p>[</span><span class=n>kTileWidth</span><span class=p>][</span><span class=n>kTileWidth</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kTileWidth</span><span class=p>][</span><span class=n>kTileWidth</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=o>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=o>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>tx</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=o>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>ty</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=o>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>_m</span> <span class=o>=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kTileWidth</span> <span class=o>+</span> <span class=n>ty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>_n</span> <span class=o>=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kTileWidth</span> <span class=o>+</span> <span class=n>tx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>c_value</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>/*</span> <span class=n>k</span> <span class=n>operations</span> <span class=n>of</span> <span class=n>multiply</span><span class=o>-</span><span class=n>add</span> <span class=n>are</span> <span class=n>divided</span> <span class=n>into</span> <span class=n>phases</span><span class=p>,</span> <span class=n>each</span> <span class=n>phase</span> <span class=n>correspond</span> <span class=n>to</span> <span class=n>an</span>
</span></span><span class=line><span class=cl>   <span class=o>*</span> <span class=n>iteration</span> <span class=n>of</span> <span class=k>for</span><span class=o>-</span><span class=n>loop</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=p>::</span><span class=nb>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kTileWidth</span><span class=p>);</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>/*</span> <span class=n>Collectively</span> <span class=nb>load</span> <span class=n>data</span> <span class=n>into</span> <span class=n>shared</span> <span class=n>memory</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_m</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads</span><span class=p>[</span><span class=n>ty</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>(</span><span class=n>_m</span><span class=p>,</span> <span class=n>ph</span> <span class=o>*</span> <span class=n>kTileWidth</span> <span class=o>+</span> <span class=n>tx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads</span><span class=p>[</span><span class=n>ty</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_n</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>Bds</span><span class=p>[</span><span class=n>ty</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=n>B</span><span class=p>(</span><span class=n>ph</span> <span class=o>*</span> <span class=n>kTileWidth</span> <span class=o>+</span> <span class=n>ty</span><span class=p>,</span> <span class=n>_n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>Bds</span><span class=p>[</span><span class=n>ty</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>Make</span> <span class=n>sure</span> <span class=n>all</span> <span class=n>threads</span> <span class=ow>in</span> <span class=n>block</span> <span class=n>finished</span> <span class=n>loading</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>/*</span> <span class=n>Do</span> <span class=n>multiple</span><span class=o>-</span><span class=n>add</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kTileWidth</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=n>c_value</span> <span class=o>+=</span> <span class=n>Ads</span><span class=p>[</span><span class=n>ty</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>*</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>tx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>Make</span> <span class=n>sure</span> <span class=n>all</span> <span class=n>threads</span> <span class=ow>in</span> <span class=n>block</span> <span class=n>finished</span> <span class=n>using</span> <span class=n>shared</span> <span class=n>memory</span><span class=p>,</span> <span class=n>so</span> <span class=n>that</span> <span class=n>we</span> <span class=n>can</span> <span class=n>go</span> <span class=n>into</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>next</span> <span class=n>iteration</span>
</span></span><span class=line><span class=cl>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>_m</span> <span class=o>&lt;</span> <span class=n>m</span> <span class=o>&amp;&amp;</span> <span class=n>_n</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=n>C</span><span class=p>(</span><span class=n>_m</span><span class=p>,</span> <span class=n>_n</span><span class=p>)</span> <span class=o>=</span> <span class=n>c_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>MyMatMul</span><span class=p>(</span><span class=ne>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=ne>int</span> <span class=n>m</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>,</span> <span class=ne>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>constexpr</span> <span class=ne>int</span> <span class=n>kTileWidth</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>block</span><span class=p>(</span><span class=n>kTileWidth</span><span class=p>,</span> <span class=n>kTileWidth</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>grid</span><span class=p>((</span><span class=n>n</span> <span class=o>+</span> <span class=n>kTileWidth</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kTileWidth</span><span class=p>,</span> <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>kTileWidth</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kTileWidth</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MyMatMulKernel</span><span class=o>&lt;</span><span class=n>kTileWidth</span><span class=o>&gt;&lt;&lt;&lt;</span><span class=n>grid</span><span class=p>,</span> <span class=n>block</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>d_C</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的写法大部分是直接用了 PMPP 书中 kernel 的写法。这一版可以达到大概 2.9 TFLOPS（小小进步）。</p><p>我们这里可以简单计算一下，每个线程的访存（只考虑读）次数：</p><ul><li>GMEM：K / kTileWidth * 2 loads，代入数值（kTileWidth = 16）得到 K / 8 loads</li><li>SMEM：K * 2 loads</li></ul><p>这里因为每个线程输出一个结果元素，所以每个结果元素的访存次数和每个线程的访存次数是相等的。</p><h2 id=第三版实现thread-coarsening>第三版实现：thread coarsening</h2><p>这一版就比较有意思了，我们先来说一下应用的优化手法。手法是 PMPP 第 6.3 节中提到的 thread coarsening，即增加每个线程的颗粒度，不要使一个线程只负责一个元素。因为这种很细的颗粒度会导致很多的线程，所以会导致很多的 block。而当 block 或线程数很多的时候，在 GPU 中 block 之间会开始串行执行，这就增加了运行的 overhead。</p><p>还是拿我的 RTX 3090 举例，当我们设置三个矩阵都是 $1024 \times 1024$ 的方阵时，如果我们用最细颗粒度和 $16 \times 16 = 256$ 的 block 大小（随意定的），那么我们会有 4096 个 block。</p><p>然而查表可知，RTX 3090 每个 SM 最多支持 1536 个线程，16 个 block。因为我们的 block 大小是 256 个线程，所以由于每个 SM 上最大线程数（1536）的限制，一个 SM 只会分到 $1536 \div 256 = 6$ 个 block。而 RTX 3090 一共只有 82 个 SM，所以总共的 4096 个 block 需要 $4096 \div 6 \div 82 \approx 8.33$ <em>轮</em>。这个轮在官方语言中称为 <em>waves</em>。在使用 Nsight Compute 进行 profiling 时，我们能看到这样一个属性就是“Waves per SM”，它的值也确实是我们计算的 8.33。</p><p><img src=/p/cuda_gemm_opt/waves_per_sm.jpg width=1822 height=1250 srcset="/p/cuda_gemm_opt/waves_per_sm_hu_832127b36bd759c6.jpg 480w, /p/cuda_gemm_opt/waves_per_sm_hu_9dab2a05ce70b13d.jpg 1024w" loading=lazy alt="在对第二版实现使用 Nsight Compute 进行 profiling 时的性能报告，其中高亮的是“Waves per SM”。" class=gallery-image data-flex-grow=145 data-flex-basis=349px></p><p>可以想象这每一轮都会有并行计算的一些 overhead（如 block 的调度开销等），所以我们可以让一个线程多处理几个元素，从而减小 block 的大小，同时也减小了总线程数。这是我们的第三版实现，在第二版上增加了一个 <code>stride</code> 选项，控制一个线程会计算多少个元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#define A(s, i, j) d_A[((i) + s * kTileWidthY) * k + (j)]</span>
</span></span><span class=line><span class=cl><span class=c1>#define B(s, i, j) d_B[((i) + s * kTileWidthY) * n + (j)]</span>
</span></span><span class=line><span class=cl><span class=c1>#define C(s, i, j) d_C[((i) + s * kTileWidthY) * n + (j)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=n>Tiled</span> <span class=n>version</span> <span class=n>with</span> <span class=n>thread</span> <span class=n>coarsening</span>
</span></span><span class=line><span class=cl><span class=n>template</span> <span class=o>&lt;</span><span class=ne>int</span> <span class=n>kTileWidthX</span><span class=p>,</span> <span class=ne>int</span> <span class=n>kTileWidthY</span><span class=p>,</span> <span class=ne>int</span> <span class=n>kStrideY</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=n>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=ne>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=ne>int</span> <span class=n>m</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>,</span> <span class=ne>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads</span><span class=p>[</span><span class=n>kTileWidthX</span><span class=p>][</span><span class=n>kTileWidthY</span> <span class=o>*</span> <span class=n>kStrideY</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kTileWidthX</span><span class=p>][</span><span class=n>kTileWidthY</span> <span class=o>*</span> <span class=n>kStrideY</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>tx</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=o>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>ty</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=o>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=o>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=o>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>_m</span> <span class=o>=</span> <span class=n>by</span> <span class=o>*</span> <span class=p>(</span><span class=n>kTileWidthY</span> <span class=o>*</span> <span class=n>kStrideY</span><span class=p>)</span> <span class=o>+</span> <span class=n>ty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=ne>int</span> <span class=n>_n</span> <span class=o>=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kTileWidthX</span> <span class=o>+</span> <span class=n>tx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kStrideY</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=o>/*</span> <span class=n>k</span> <span class=n>operations</span> <span class=n>of</span> <span class=n>multiply</span><span class=o>-</span><span class=n>add</span> <span class=n>are</span> <span class=n>divided</span> <span class=n>into</span> <span class=n>phases</span><span class=p>,</span> <span class=n>each</span> <span class=n>phase</span> <span class=n>correspond</span> <span class=n>to</span> <span class=n>an</span>
</span></span><span class=line><span class=cl>   <span class=o>*</span> <span class=n>iteration</span> <span class=n>of</span> <span class=k>for</span><span class=o>-</span><span class=n>loop</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=p>::</span><span class=nb>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kTileWidthX</span><span class=p>);</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>s</span> <span class=o>&lt;</span> <span class=n>kStrideY</span><span class=p>;</span> <span class=o>++</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=o>/*</span> <span class=n>Collectively</span> <span class=nb>load</span> <span class=n>data</span> <span class=n>into</span> <span class=n>shared</span> <span class=n>memory</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span> <span class=o>+</span> <span class=n>_m</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Ads</span><span class=p>[</span><span class=n>ty</span> <span class=o>+</span> <span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>_m</span><span class=p>,</span> <span class=n>ph</span> <span class=o>*</span> <span class=n>kTileWidthX</span> <span class=o>+</span> <span class=n>tx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>Ads</span><span class=p>[</span><span class=n>ty</span> <span class=o>+</span> <span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>_n</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Bds</span><span class=p>[</span><span class=n>ty</span> <span class=o>+</span> <span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=n>B</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>ph</span> <span class=o>*</span> <span class=n>kTileWidthX</span> <span class=o>+</span> <span class=n>ty</span><span class=p>,</span> <span class=n>_n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>Bds</span><span class=p>[</span><span class=n>ty</span> <span class=o>+</span> <span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span><span class=p>][</span><span class=n>tx</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>Make</span> <span class=n>sure</span> <span class=n>all</span> <span class=n>threads</span> <span class=ow>in</span> <span class=n>block</span> <span class=n>finished</span> <span class=n>loading</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=k>if</span> <span class=p>(</span><span class=n>by</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>bx</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>tx</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>ty</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%f</span><span class=s2> </span><span class=si>%f</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>_m</span><span class=p>,</span> <span class=n>_n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>s</span> <span class=o>&lt;</span> <span class=n>kStrideY</span><span class=p>;</span> <span class=o>++</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kTileWidthX</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=o>/*</span> <span class=n>Do</span> <span class=n>multiple</span><span class=o>-</span><span class=n>add</span> <span class=o>*/</span>
</span></span><span class=line><span class=cl>        <span class=n>c_value</span><span class=p>[</span><span class=n>s</span><span class=p>]</span> <span class=o>+=</span> <span class=n>Ads</span><span class=p>[</span><span class=n>ty</span> <span class=o>+</span> <span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>*</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>tx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>Make</span> <span class=n>sure</span> <span class=n>all</span> <span class=n>threads</span> <span class=ow>in</span> <span class=n>block</span> <span class=n>finished</span> <span class=n>using</span> <span class=n>shared</span> <span class=n>memory</span><span class=p>,</span> <span class=n>so</span> <span class=n>that</span> <span class=n>we</span> <span class=n>can</span> <span class=n>go</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>into</span> <span class=n>next</span> <span class=n>iteration</span>
</span></span><span class=line><span class=cl>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=ne>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>s</span> <span class=o>&lt;</span> <span class=n>kStrideY</span><span class=p>;</span> <span class=o>++</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>*</span> <span class=n>kTileWidthY</span> <span class=o>+</span> <span class=n>_m</span> <span class=o>&lt;</span> <span class=n>m</span> <span class=o>&amp;&amp;</span> <span class=n>_n</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=n>C</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>_m</span><span class=p>,</span> <span class=n>_n</span><span class=p>)</span> <span class=o>=</span> <span class=n>c_value</span><span class=p>[</span><span class=n>s</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>MyMatMul</span><span class=p>(</span><span class=ne>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=ne>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=ne>int</span> <span class=n>m</span><span class=p>,</span> <span class=ne>int</span> <span class=n>n</span><span class=p>,</span> <span class=ne>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>constexpr</span> <span class=ne>int</span> <span class=n>kTileWidthX</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>constexpr</span> <span class=ne>int</span> <span class=n>kTileWidthY</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>constexpr</span> <span class=ne>int</span> <span class=n>kStrideY</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>block</span><span class=p>(</span><span class=n>kTileWidthX</span><span class=p>,</span> <span class=n>kTileWidthY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>grid</span><span class=p>((</span><span class=n>n</span> <span class=o>+</span> <span class=n>kTileWidthX</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kTileWidthX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=p>(</span><span class=n>kTileWidthY</span> <span class=o>*</span> <span class=n>kStrideY</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>kTileWidthY</span> <span class=o>*</span> <span class=n>kStrideY</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MyMatMulKernel</span><span class=o>&lt;</span><span class=n>kTileWidthX</span><span class=p>,</span> <span class=n>kTileWidthY</span><span class=p>,</span> <span class=n>kStrideY</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;&lt;&lt;</span><span class=n>grid</span><span class=p>,</span> <span class=n>block</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>d_C</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在这份代码里，为了不显著地增加每个 block 的 shared memory 用量，我们将每个 block 实际负责的 tile 大小依然定为 $16 \times 16$，而 <code>kStrideY</code> 被用来控制每个线程负责的元素数量，从而控制了 block 中的线程大小。注意到每个 block 的大小现在是 <code>kTileWidthX * kTileWidthY</code>。而为了保证 tile 大小仍是 $16 \times 16$，我们要人为地保证 <code>kTileWidthY * kStrideY = 16</code>。所以显而易见地，如果我们将 <code>kStrideY</code> 设为 1，则它会回退到第二版实现；如果我们将<code>kStrideY</code> 设为 2、4、8 或 16，则可以进行我们上面讲的 thread coarsening。</p><p>在这一版中，由于我进行了上面的计算，所以我发现，如果 stride 超过 2，比如 stride 为 4 时，每个 block 的大小为 64 个线程，这样每个 block 的线程就会过小，使得 SM 填不满。上面我们提到，一个 SM 中只能驻 16 个 block，所以在这种情况下只能驻 $16 \times 64 = 1024$ 个线程。这会让 occupancy 掉至 $1024 \div 1536 \approx 66.7$%。所以这里我先令 stride 为 2，测试结果可以达到大约 4.1 TFLOPS（又一个小小进步）。</p><h3 id=分析stride-调参>分析：stride 调参</h3><p>这里当然既然有 stride 这个参数，不妨试一下各个参数值的效果。我测试了四个不同的参数值结果如下：</p><div class=table-wrapper><table><thead><tr><th>stride</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>计算吞吐量（TFLOPS）</td><td>2.9</td><td>4.1</td><td>5.1</td><td>6.0</td><td>3.8</td></tr><tr><td>Block 线程数</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td></tr><tr><td>理论 Occupancy</td><td>100%</td><td>100%</td><td>66.67%</td><td>33.33%</td><td>33.33%</td></tr><tr><td>实际 Occupancy</td><td>95.75%</td><td>90.90%</td><td>59.86%</td><td>30.29%</td><td>29.42%</td></tr></tbody></table></div><p>可以发现这里很“反逻辑”的一点是随着 occupancy 变低，效率反而越来越高，直到 stride 到达 16。stride 到达 16 时，一个 block 的线程数已经低于 32 了，而 warp 是以 32 个线程为一组的，所以很显然浪费了很多效率。但是在 stride 从 1 到 8 的时候效率是不断提升的。</p><p>为了研究这个问题的原因，我搜到了一个 talk《Better Performance at Lower Occupancy》，我阅读的笔记放在<a class=link href=https://georgelyu.github.io/p/lower_occupancy_note/>这篇文章</a>里。</p><p>在这篇 talk 里，它的 case study 就是讲的 GEMM 的 thread coarsening，可以说和我这里的第三版的修改一模一样。在分析这个原因时，该 talk 中提到一个很重要的点，就是对于 GEMM 这样的 memory-intensive 的应用，计算单元的计算吞吐量是用不完的。RTX 3090 的一个 SM 的计算吞吐量是 $35.58\text{ TFLOPS } \div 82\text{ SMs }\approx 444.3\text{ GFLOPS}$。但是可以看到，我们这里的每一次乘加，都需要访问两个浮点数。所以要跑满这个计算吞吐量，我们需要 $444.3\text{ GFLOPS } \div 2\text{ ops } \times 8\text{ B } = 1777.2\text{ GB/s }$。即使我们已经把元素整体地预先 load 到 shared memory 里面了，然而 shared memory 的带宽是 $32 \text{ banks } * 4\text{ B/bank } * 1.395\text{ GHz }= 178.56\text{ GB/s}$。很明显，shared memory 的带宽依然是瓶颈。</p><p>回到我们这个例子，我们注意到在第三版代码中的第 44 行有一个 <code>Bds[k][tx]</code>，这个元素是会被重用的。所以这里就减少了 shared memory 的读写。</p><p>同样算一下每个线程的访存（只考虑读）次数：</p><ul><li>GMEM：K / kTileWidth * stride * 2 loads，代入数值（kTileWidth = 16，stride = 8）得到 K loads</li><li>SMEM：K * (stride + 1) loads，代入数值（kTileWidth = 16，stride = 8）得到 K * 9 loads</li></ul><p>但是一个线程现在输出 8 个元素了所以每个结果元素需要的访存量变为：</p><ul><li>GMEM：K / 8 loads</li><li>SMEM：K * 9 / 8 loads</li></ul><p>当然我们要验证一下我们的想法对不对，在 Nsight Compute 中我们还能得到下面的一些性能指标：</p><div class=table-wrapper><table><thead><tr><th>stride</th><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th></tr></thead><tbody><tr><td>每线程寄存器量</td><td>38</td><td>40</td><td>40</td><td>52</td><td>72</td></tr><tr><td>shared memory load 语句执行量</td><td>83.89 M</td><td>50.33 M</td><td>33.55 M</td><td>25.17 M</td><td>41.94 M</td></tr><tr><td>FMA 利用率（% active cycle）</td><td>10.69</td><td>15.66</td><td>20.89</td><td>24.09</td><td>26.98</td></tr></tbody></table></div><p>确实如我们所预料，shared memory 的加载数量在减小，同时 FMA 单元利用率在提升。</p><h2 id=第四版实现2d-thread-coarsening>第四版实现：2D thread coarsening</h2><p>那么我们基本已经确定要进一步提升计算吞吐量，所以我们要进一步减少访存量（这里说的访存是包含 shared memory 的）。所以我们进一步加强 thread coarsening 的强度，令一个线程计算 8 * 8 个元素。所以我们抛弃第三版中的 <code>kStride</code>，用二维的 <code>kThreadWorkDimX</code> 和 <code>kThreadWorkDimY</code>，表示一个 thread 的工作范围。</p><p>下面的实现参考了<a class=link href=https://github.com/siboehm/SGEMM_CUDA/blob/master/src/kernels/5_kernel_2D_blocktiling.cuh target=_blank rel=noopener>这里</a>的源码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define A(i, j) d_A[(i) * k + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define B(i, j) d_B[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define C(i, j) d_C[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Tiled version with 2D thread coarsening
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kTileDimK</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=kt>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Introduce kTileDimK, so the tile is not square, otherwise it would be too large
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads</span><span class=p>[</span><span class=n>kBlockWorkDimY</span><span class=p>][</span><span class=n>kTileDimK</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// (thread_outer_x, thread_outer_y) is the thread&#39;s outer position w.r.t. block.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>thread_outer_x</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>thread_outer_y</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Move tile to beginning of d_A&#39;s row and d_B&#39;s column
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_A</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_B</span> <span class=o>+=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_C</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate the indices that this thread will load into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>kTileDimK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=n>kTileDimK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// The stride is for GMEM coalescing
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>thread_num_in_block</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>kThreadWorkDimX</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>strideA</span> <span class=o>=</span> <span class=n>thread_num_in_block</span> <span class=o>/</span> <span class=n>kTileDimK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>strideB</span> <span class=o>=</span> <span class=n>thread_num_in_block</span> <span class=o>/</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Register caches for Ads and Bds
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kThreadWorkDimY</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* k operations of multiply-add are divided into phases, each phase correspond to an
</span></span></span><span class=line><span class=cl><span class=cm>   * iteration of for-loop */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kTileDimK</span><span class=p>);</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Collectively load data into shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockWorkDimY</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads</span><span class=p>[</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>][</span><span class=n>Ads_col</span><span class=p>]</span> <span class=o>=</span> <span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kTileDimK</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>Bds</span><span class=p>[</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>][</span><span class=n>Bds_col</span><span class=p>]</span> <span class=o>=</span> <span class=n>B</span><span class=p>(</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Bds_col</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished loading data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Advance tile
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_A</span> <span class=o>+=</span> <span class=n>kTileDimK</span><span class=p>;</span>      <span class=c1>// move kTileDimK columns to right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_B</span> <span class=o>+=</span> <span class=n>kTileDimK</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>// move kTileDimK rows down
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate per-thread results
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kTileDimK</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// SMEM to registers
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>A_reg</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Ads</span><span class=p>[</span><span class=n>thread_outer_y</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>B_reg</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>thread_outer_x</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>cx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>c_value</span><span class=p>[</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>cy</span><span class=p>]</span> <span class=o>*</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>cx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished using shared memory, so that we can go
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// into next iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Write results to GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>cx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>C</span><span class=p>(</span><span class=n>thread_outer_y</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>cy</span><span class=p>,</span> <span class=n>thread_outer_x</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>cx</span><span class=p>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>c_value</span><span class=p>[</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MyMatMul</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This is LOGICAL, not REAL block dim.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kThreadWorkDimY</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// kBlockWorkDimX/kThreadWorkDimX and kBlockWorkDimY/kThreadWorkDimY must be exact
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// division.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockWorkDimX</span> <span class=o>=</span> <span class=mi>8</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span> <span class=o>=</span> <span class=mi>8</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kTileDimK</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>block</span><span class=p>((</span><span class=n>kBlockWorkDimX</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>kThreadWorkDimX</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>grid</span><span class=p>((</span><span class=n>n</span> <span class=o>+</span> <span class=n>kBlockWorkDimX</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>kBlockWorkDimY</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockWorkDimY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MyMatMulKernel</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>kTileDimK</span><span class=o>&gt;&lt;&lt;&lt;</span><span class=n>grid</span><span class=p>,</span> <span class=n>block</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>d_C</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这个优化的关键在于第 60-70 行。通过 2D 的 thread coarsening，原理与 1D thread coarsening 类似，但是元素的重用可以更多。可以以 (kThreadWorkDimX + kThreadWorkDimY) 次 shared memory 加载进行 (kThreadWorkDimX * kThreadWorkDimY) 次乘加计算（图示过程参考<a class=link href=https://siboehm.com/articles/22/CUDA-MMM target=_blank rel=noopener>该文的 Kernel 5 部分</a>）和<a class=link href=https://zhuanlan.zhihu.com/p/441146275 target=_blank rel=noopener>该文的第 1.3 节</a>。</p><p>这时每个线程需要的访存量（只考虑读）变为：</p><ul><li>GMEM：K / 8 (outer loop iters) * 2 (A+B) * 512/64 (sizeSMEM/numThreads) loads，为 K * 2 loads</li><li>SMEM：K / 8 (outer loop iters) * 8 (kTileDimK) * (8 + 8) (kThreadWorkDimY + kThreadWorkDimX) loads，为 K * 16 loads</li></ul><p>则每个结果元素需要的访存量（只考虑读）变为：</p><ul><li>GMEM：K / 32 loads</li><li>SMEM：K / 2 loads</li></ul><p>经过测试，这时性能已经来到了 15 TFLOPS，相比之前最高的 6 TFLOPS 可以说达到了质的飞跃。</p><h2 id=第五版实现vectorized-memory-access>第五版实现：vectorized memory access</h2><p>这一版主要做了两个改变：</p><ol><li>在数据从 GMEM 读到 SMEM 时，把 As 进行转置，这样子可以进行 SMEM 的合并读取；</li><li>在读写 GMEM 和 SMEM 时使用 <code>float4</code>，以使用向量化的指令（如 <code>lde.e.128</code>、<code>stg.e.128</code>、<code>lds.128</code>、<code>sts.128</code>等）</li></ol><p>代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define A(i, j) d_A[(i) * k + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define B(i, j) d_B[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define C(i, j) d_C[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Tiled version with 2D thread coarsening and vectorized memory access
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kTileDimK</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=kt>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Introduce kTileDimK, so the tile is not square, otherwise it would be too large
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Here Ads is transposed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// (thread_outer_x, thread_outer_y) is the thread&#39;s outer position w.r.t. block.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>thread_outer_x</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>thread_outer_y</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Move tile to beginning of d_A&#39;s row and d_B&#39;s column
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_A</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_B</span> <span class=o>+=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_C</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate the indices that this thread will load into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// The stride is for GMEM coalescing
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>thread_num_in_block</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>kThreadWorkDimX</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>strideA</span> <span class=o>=</span> <span class=n>thread_num_in_block</span> <span class=o>/</span> <span class=p>(</span><span class=n>kTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>strideB</span> <span class=o>=</span> <span class=n>thread_num_in_block</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Register caches for Ads and Bds
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kThreadWorkDimY</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* k operations of multiply-add are divided into phases, each phase correspond to an
</span></span></span><span class=line><span class=cl><span class=cm>   * iteration of for-loop */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kTileDimK</span><span class=p>);</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Collectively load data into shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockWorkDimY</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideA</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Here A is transpoed and saved into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>float4</span> <span class=n>tmp</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>))[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kTileDimK</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bds</span><span class=p>[</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>][</span><span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>B</span><span class=p>(</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>))[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished loading data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Advance tile
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_A</span> <span class=o>+=</span> <span class=n>kTileDimK</span><span class=p>;</span>      <span class=c1>// move kTileDimK columns to right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_B</span> <span class=o>+=</span> <span class=n>kTileDimK</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>// move kTileDimK rows down
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate per-thread results
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kTileDimK</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// SMEM to registers
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// Due to transposed A in SMEM, the row and col indicies are switched
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>A_reg</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>thread_outer_y</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>B_reg</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>thread_outer_x</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>cx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>c_value</span><span class=p>[</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>cy</span><span class=p>]</span> <span class=o>*</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>cx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished using shared memory, so that we can go
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// into next iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Write results to GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=n>cx</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>C</span><span class=p>(</span><span class=n>thread_outer_y</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>cy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=n>thread_outer_x</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>cx</span><span class=p>))[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c_value</span><span class=p>[</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>])[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MyMatMul</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This is LOGICAL, not REAL block dim.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kThreadWorkDimY</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// kBlockWorkDimX/kThreadWorkDimX and kBlockWorkDimY/kThreadWorkDimY must be exact
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// division.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockWorkDimX</span> <span class=o>=</span> <span class=mi>8</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span> <span class=o>=</span> <span class=mi>8</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kTileDimK</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>block</span><span class=p>((</span><span class=n>kBlockWorkDimX</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>kThreadWorkDimX</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>grid</span><span class=p>((</span><span class=n>n</span> <span class=o>+</span> <span class=n>kBlockWorkDimX</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>kBlockWorkDimY</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockWorkDimY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MyMatMulKernel</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>kTileDimK</span><span class=o>&gt;&lt;&lt;&lt;</span><span class=n>grid</span><span class=p>,</span> <span class=n>block</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>d_C</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这一版的效率可以达到约 18 TFLOPS。</p><h2 id=第六版实现warp-tiling>第六版实现：warp tiling</h2><p>在第四版实现时我们说了，现在一个 thread tile 可以用 (kThreadWorkDimX + kThreadWorkDimY) 次 shared memory 加载进行 (kThreadWorkDimX * kThreadWorkDimY) 次乘加计算。所以很明显，在乘积确定时，kThreadWorkDimX 和 kThreadWorkDimY 越接近，算存比会越高。</p><p>那么对于一个 warp 的 32 个线程来说，这一过程是要进行 32 次的。我们可以认为每个 thread 在把数据从 SMEM 移至寄存器时，我们无形中是获得了 32 个 thread tile 在 warp 上。而这 32 个 thread tile 如果没有经过任何排布，比如是排成一行，那么可以想象，就和一个排成一行的 thread tile 一样，并没有最大化算存比。</p><p>所以通过使用 warp tile，即把 warp 也做类似的 coarsening，我们能做到的一个重要的事情是，我们可以手动控制这个 warp 的 thread tile 的分布。所以我们可以通过控制维度来让 warp 内 thread tile 的排列变成尽可能方形的，来最大化算存比。</p><p>同时我们注意到，在 kThreadWorkDimX = kThreadWorkDimY 时，这个值越大，算存比就越大。所以这样做给我们带来的另一个好处是，我们变相获得了一个很大的 thread tile。</p><p><img src=/p/cuda_gemm_opt/warp_tiles.jpg width=1511 height=1065 srcset="/p/cuda_gemm_opt/warp_tiles_hu_828b93c46c45adbd.jpg 480w, /p/cuda_gemm_opt/warp_tiles_hu_d4a3d46276a2088b.jpg 1024w" loading=lazy alt="Warp tile 的示意图”。" class=gallery-image data-flex-grow=141 data-flex-basis=340px></p><p>代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define A(i, j) d_A[(i) * k + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define B(i, j) d_B[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define C_interim(i, j) d_C_interim[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Tiled version with 2D thread coarsening, vectorized memory access and 2D warp tiling
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadNumInBlock</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=kt>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Introduce kTileDimK, so the tile is not square, otherwise it would be too large
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Here Ads is transposed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpSize</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>warpIdx</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>kWarpSize</span><span class=p>;</span>  <span class=c1>// the warp this thread is in
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>wy</span> <span class=o>=</span> <span class=n>warpIdx</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>wx</span> <span class=o>=</span> <span class=n>warpIdx</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// thread&#39;s position w.r.t. warp tile (ACTUAL warp).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>threadIdxInWarp</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=n>kWarpSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>ty_in_acutal_warp</span> <span class=o>=</span> <span class=n>threadIdxInWarp</span> <span class=o>/</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>tx_in_acutal_warp</span> <span class=o>=</span> <span class=n>threadIdxInWarp</span> <span class=o>%</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Move tile to beginning of d_A&#39;s row and d_B&#39;s column
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_A</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_B</span> <span class=o>+=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Here output position needs to go to warp output position
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_C</span> <span class=o>+=</span> <span class=p>(</span><span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>+</span> <span class=n>wy</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>         <span class=n>wx</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate the indices that this thread will load into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>strideA</span> <span class=o>=</span> <span class=n>kThreadNumInBlock</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>strideB</span> <span class=o>=</span> <span class=n>kThreadNumInBlock</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileNumY</span> <span class=o>=</span> <span class=n>kWarpWorkDimY</span> <span class=o>/</span> <span class=n>kWarpTileWorkDimY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileNumX</span> <span class=o>=</span> <span class=n>kWarpWorkDimX</span> <span class=o>/</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Register caches for Ads and Bds (on the warptile level)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Results are in register file in warp scheduler
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* k operations of multiply-add are divided into phases, each phase correspond to an
</span></span></span><span class=line><span class=cl><span class=cm>   * iteration of for-loop */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kBlockTileDimK</span><span class=p>);</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Collectively load data into shared memory */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockWorkDimY</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideA</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Here A is transpoed and saved into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>float4</span> <span class=n>tmp</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>))[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockTileDimK</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bds</span><span class=p>[</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>][</span><span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>B</span><span class=p>(</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>))[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished loading data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Advance tile
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_A</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span><span class=p>;</span>      <span class=c1>// move kTileDimK columns to right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_B</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>// move kTileDimK rows down
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Calculate per-thread results
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kBlockTileDimK</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// SMEM to registers
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// Due to transposed A in SMEM, the row and col indicies are switched
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>A_reg</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>wy</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span> <span class=o>+</span> <span class=n>w_sub_y</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                       <span class=n>ty_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>B_reg</span><span class=p>[</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>wx</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span> <span class=o>+</span> <span class=n>w_sub_x</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                     <span class=n>tx_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>cx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>              <span class=n>c_value</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>]</span> <span class=o>+=</span>
</span></span><span class=line><span class=cl>                  <span class=n>A_reg</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>cy</span><span class=p>]</span> <span class=o>*</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished using shared memory, so that we can go
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// into next iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Write results to GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// move C pointer to current warp subtile
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>Value_t</span><span class=o>*</span> <span class=n>d_C_interim</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>d_C</span> <span class=o>+</span> <span class=p>(</span><span class=n>w_sub_y</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>w_sub_x</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=n>cx</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=o>&amp;</span><span class=n>C_interim</span><span class=p>(</span><span class=n>ty_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>cy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>tx_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>cx</span><span class=p>))[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>              <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c_value</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>])[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MyMatMul</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This is LOGICAL, not REAL block dim.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kNumOfThreads</span> <span class=o>=</span> <span class=mi>128</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpSize</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kNumOfWarps</span> <span class=o>=</span> <span class=n>kNumOfThreads</span> <span class=o>/</span> <span class=n>kWarpSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>  <span class=c1>// in elemenets
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kThreadWorkDimY</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>  <span class=c1>// in elemenets
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// The work dim of one ACTUAL warp
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimX</span> <span class=o>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span>  <span class=c1>// 16 (in elemenets)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimY</span> <span class=o>=</span> <span class=n>kWarpSize</span> <span class=o>/</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>)</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>                                <span class=n>kThreadWorkDimY</span><span class=p>;</span>  <span class=c1>// 64 (in elemenets)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// The work dim of one LOGICAL warp
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpWorkDimX</span> <span class=o>=</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>  <span class=c1>// 64 (in elemenets)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpWorkDimY</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span><span class=p>;</span>  <span class=c1>// 64 (in elemenets)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockWorkDimX</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span><span class=p>;</span>  <span class=c1>// 128 (in elemenets)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span><span class=p>;</span>  <span class=c1>// 128 (in elemenets)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span> <span class=o>=</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>%</span> <span class=n>kWarpWorkDimX</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>kBlockWorkDimY</span> <span class=o>%</span> <span class=n>kWarpWorkDimY</span> <span class=o>==</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;Block work dim is integral multiple of warp work dim.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>kBlockWorkDimY</span> <span class=o>/</span> <span class=n>kWarpWorkDimY</span><span class=p>)</span> <span class=o>==</span> <span class=n>kNumOfWarps</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;Number of warps times its work dim should be equal to block work dim.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>((</span><span class=n>kWarpWorkDimY</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span><span class=p>)</span> <span class=o>%</span>
</span></span><span class=line><span class=cl>                        <span class=p>(</span><span class=n>kWarpSize</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>*</span> <span class=n>kNumOfWarps</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>                    <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;Warp work dim is integral multiple of thread work dim.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>(</span><span class=n>kWarpWorkDimX</span> <span class=o>%</span> <span class=n>kNumOfWarps</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;Warp work dim is multiple of NUM_WARP&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>((</span><span class=n>kNumOfThreads</span> <span class=o>*</span> <span class=mi>4</span><span class=p>)</span> <span class=o>%</span> <span class=n>kBlockTileDimK</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;NUM_THREADS*4 must be multiple of kTileDimK to avoid quantization &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;issues during GMEM-&gt;SMEM tiling (loading only parts of the &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;final row of Bs during each iteraion)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>((</span><span class=n>kNumOfThreads</span> <span class=o>*</span> <span class=mi>4</span><span class=p>)</span> <span class=o>%</span> <span class=n>kBlockWorkDimX</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;NUM_THREADS*4 must be multiple of kBlockWorkDimX to avoid quantization &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;issues during GMEM-&gt;SMEM tiling (loading only parts of the &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;final row of As during each iteration)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>%</span> <span class=p>(</span><span class=mi>16</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;kBlockWorkDimX must be a multiple of 16*kThreadWorkDimX to avoid &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;quantization effects&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>(</span><span class=n>kBlockWorkDimY</span> <span class=o>%</span> <span class=p>(</span><span class=mi>16</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;kBlockWorkDimY must be a multiple of 16*kThreadWorkDimY to avoid &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;quantization effects&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>((</span><span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>kBlockTileDimK</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=mi>4</span> <span class=o>*</span> <span class=n>kNumOfThreads</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;kBlockWorkDimY*kTileDimK must be a multiple of 4*kNumOfThreads to &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;vectorize loads&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>static_assert</span><span class=p>((</span><span class=n>kBlockWorkDimX</span> <span class=o>*</span> <span class=n>kBlockTileDimK</span><span class=p>)</span> <span class=o>%</span> <span class=p>(</span><span class=mi>4</span> <span class=o>*</span> <span class=n>kNumOfThreads</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;kBlockWorkDimX*kTileDimK must be a multiple of 4*kNumOfThreads to &#34;</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;vectorize loads&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>block</span><span class=p>(</span><span class=n>kNumOfThreads</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>dim3</span> <span class=n>grid</span><span class=p>((</span><span class=n>n</span> <span class=o>+</span> <span class=n>kBlockWorkDimX</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>kBlockWorkDimY</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>kBlockWorkDimY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>MyMatMulKernel</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>kNumOfThreads</span><span class=o>&gt;&lt;&lt;&lt;</span><span class=n>grid</span><span class=p>,</span> <span class=n>block</span><span class=o>&gt;&gt;&gt;</span><span class=p>(</span><span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>d_C</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这一版的效率可以大概达到 20TFLOPS。</p><h2 id=第七版实现函数化封装>第七版实现：函数化封装</h2><p>为了接来下 double buffer 的实现，我们先把现在这一版实现做一下函数封装。代码如下（只包含 kernel 部分，因为调用部分不变）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define A(i, j) d_A[(i) * k + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define B(i, j) d_B[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define C_interim(i, j) d_C_interim[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>strideA</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>strideB</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__device__</span> <span class=kt>void</span> <span class=n>LoadFromGmem</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=kt>float</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                             <span class=kt>float</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=kt>int</span> <span class=n>Ads_col</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Ads_row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Bds_row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Bds_col</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Collectively load data into shared memory */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockWorkDimY</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideA</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Here A is transpoed and saved into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>float4</span> <span class=n>tmp</span> <span class=o>=</span> <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>))[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>.</span><span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockTileDimK</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bds</span><span class=p>[</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>][</span><span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>B</span><span class=p>(</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>))[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileNumY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileNumX</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__device__</span> <span class=kt>void</span> <span class=n>ProcessFromSmem</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>],</span> <span class=kt>int</span> <span class=n>wy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>wx</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ty_in_acutal_warp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>tx_in_acutal_warp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate per-thread results
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kBlockTileDimK</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SMEM to registers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Due to transposed A in SMEM, the row and col indicies are switched
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>A_reg</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>wy</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span> <span class=o>+</span> <span class=n>w_sub_y</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                     <span class=n>ty_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>B_reg</span><span class=p>[</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>wx</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span> <span class=o>+</span> <span class=n>w_sub_x</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                   <span class=n>tx_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>cx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>c_value</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>cy</span><span class=p>]</span> <span class=o>*</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Tiled version with 2D thread coarsening, vectorized memory access and 2D warp tiling
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadNumInBlock</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=kt>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Introduce kTileDimK, so the tile is not square, otherwise it would be too large
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Here Ads is transposed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpSize</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>warpIdx</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>kWarpSize</span><span class=p>;</span>  <span class=c1>// the warp this thread is in
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>wy</span> <span class=o>=</span> <span class=n>warpIdx</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>wx</span> <span class=o>=</span> <span class=n>warpIdx</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// thread&#39;s position w.r.t. warp tile (ACTUAL warp).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>threadIdxInWarp</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=n>kWarpSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>ty_in_acutal_warp</span> <span class=o>=</span> <span class=n>threadIdxInWarp</span> <span class=o>/</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>tx_in_acutal_warp</span> <span class=o>=</span> <span class=n>threadIdxInWarp</span> <span class=o>%</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Move tile to beginning of d_A&#39;s row and d_B&#39;s column
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_A</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_B</span> <span class=o>+=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Here output position needs to go to warp output position
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_C</span> <span class=o>+=</span> <span class=p>(</span><span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>+</span> <span class=n>wy</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>         <span class=n>wx</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate the indices that this thread will load into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>strideA</span> <span class=o>=</span> <span class=n>kThreadNumInBlock</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>strideB</span> <span class=o>=</span> <span class=n>kThreadNumInBlock</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileNumY</span> <span class=o>=</span> <span class=n>kWarpWorkDimY</span> <span class=o>/</span> <span class=n>kWarpTileWorkDimY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileNumX</span> <span class=o>=</span> <span class=n>kWarpWorkDimX</span> <span class=o>/</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Register caches for Ads and Bds (on the warptile level)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Results are in register file in warp scheduler
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* k operations of multiply-add are divided into phases, each phase correspond to an
</span></span></span><span class=line><span class=cl><span class=cm>   * iteration of for-loop */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kBlockTileDimK</span><span class=p>);</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LoadFromGmem</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>strideA</span><span class=p>,</span> <span class=n>strideB</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>Ads_T</span><span class=p>,</span> <span class=n>Bds</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>Ads_col</span><span class=p>,</span> <span class=n>Ads_row</span><span class=p>,</span> <span class=n>Bds_row</span><span class=p>,</span> <span class=n>Bds_col</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished loading data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Advance tile
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_A</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span><span class=p>;</span>      <span class=c1>// move kTileDimK columns to right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_B</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>// move kTileDimK rows down
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFromSmem</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>kWarpTileNumY</span><span class=p>,</span> <span class=n>kWarpTileNumX</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>Ads_T</span><span class=p>,</span> <span class=n>Bds</span><span class=p>,</span> <span class=n>A_reg</span><span class=p>,</span> <span class=n>B_reg</span><span class=p>,</span> <span class=n>c_value</span><span class=p>,</span> <span class=n>wy</span><span class=p>,</span> <span class=n>wx</span><span class=p>,</span> <span class=n>ty_in_acutal_warp</span><span class=p>,</span> <span class=n>tx_in_acutal_warp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished using shared memory, so that we can go
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// into next iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Write results to GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// move C pointer to current warp subtile
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>Value_t</span><span class=o>*</span> <span class=n>d_C_interim</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>d_C</span> <span class=o>+</span> <span class=p>(</span><span class=n>w_sub_y</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>w_sub_x</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=n>cx</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=o>&amp;</span><span class=n>C_interim</span><span class=p>(</span><span class=n>ty_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>cy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>tx_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>cx</span><span class=p>))[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>              <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c_value</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>])[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=第八版实现double-buffer>第八版实现：double buffer</h2><p>这一版主要是引入了 double buffer，即让 GMEM -> SMEM 和 SMEM -> REG -> 计算 这两个部分可以流水线执行。先看代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#define A(i, j) d_A[(i) * k + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define B(i, j) d_B[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp>#define C_interim(i, j) d_C_interim[(i) * n + (j)]
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>strideA</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>strideB</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__device__</span> <span class=kt>void</span> <span class=n>LoadFromGmem</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=kt>float</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                             <span class=kt>float</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=kt>int</span> <span class=n>Ads_col</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Ads_row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Bds_row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>Bds_col</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                             <span class=n>T</span><span class=o>&amp;</span> <span class=n>barrier</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Collectively load data into shared memory */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockWorkDimY</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideA</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//// Here A is transpoed and saved into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cuda</span><span class=o>::</span><span class=n>memcpy_async</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                       <span class=n>cuda</span><span class=o>::</span><span class=n>aligned_size_t</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)),</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cuda</span><span class=o>::</span><span class=n>memcpy_async</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                       <span class=n>cuda</span><span class=o>::</span><span class=n>aligned_size_t</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)),</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cuda</span><span class=o>::</span><span class=n>memcpy_async</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                       <span class=n>cuda</span><span class=o>::</span><span class=n>aligned_size_t</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)),</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cuda</span><span class=o>::</span><span class=n>memcpy_async</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ads_T</span><span class=p>[</span><span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>][</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>A</span><span class=p>(</span><span class=n>Ads_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Ads_col</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>3</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                       <span class=n>cuda</span><span class=o>::</span><span class=n>aligned_size_t</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>float</span><span class=p>)),</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>loadOffset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>&lt;</span> <span class=n>kBlockTileDimK</span><span class=p>;</span> <span class=n>loadOffset</span> <span class=o>+=</span> <span class=n>strideB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cuda</span><span class=o>::</span><span class=n>memcpy_async</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Bds</span><span class=p>[</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>][</span><span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                       <span class=o>&amp;</span><span class=n>B</span><span class=p>(</span><span class=n>Bds_row</span> <span class=o>+</span> <span class=n>loadOffset</span><span class=p>,</span> <span class=n>Bds_col</span> <span class=o>*</span> <span class=mi>4</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                       <span class=n>cuda</span><span class=o>::</span><span class=n>aligned_size_t</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=n>float4</span><span class=p>)</span><span class=o>&gt;</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>float4</span><span class=p>)),</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileNumY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileNumX</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__device__</span> <span class=kt>void</span> <span class=n>ProcessFromSmem</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>Bds</span><span class=p>[</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>],</span> <span class=kt>int</span> <span class=n>wy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>wx</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ty_in_acutal_warp</span><span class=p>,</span> <span class=kt>int</span> <span class=n>tx_in_acutal_warp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate per-thread results
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>kBlockTileDimK</span><span class=p>;</span> <span class=o>++</span><span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// SMEM to registers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Due to transposed A in SMEM, the row and col indicies are switched
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>A_reg</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>wy</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span> <span class=o>+</span> <span class=n>w_sub_y</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                     <span class=n>ty_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>B_reg</span><span class=p>[</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>Bds</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>wx</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span> <span class=o>+</span> <span class=n>w_sub_x</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                                   <span class=n>tx_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=o>++</span><span class=n>cx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>c_value</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>]</span> <span class=o>+=</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>cy</span><span class=p>]</span> <span class=o>*</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Tiled version with 2D thread coarsening, vectorized memory access and 2D warp tiling
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kt>int</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kThreadNumInBlock</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>__global__</span> <span class=kt>void</span> <span class=n>MyMatMulKernel</span><span class=p>(</span><span class=kt>float</span><span class=o>*</span> <span class=n>d_A</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_B</span><span class=p>,</span> <span class=kt>float</span><span class=o>*</span> <span class=n>d_C</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>block</span> <span class=o>=</span> <span class=n>cooperative_groups</span><span class=o>::</span><span class=n>this_thread_block</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>cuda</span><span class=o>::</span><span class=n>barrier</span><span class=o>&lt;</span><span class=n>cuda</span><span class=o>::</span><span class=n>thread_scope</span><span class=o>::</span><span class=n>thread_scope_block</span><span class=o>&gt;</span> <span class=n>frontBarrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>cuda</span><span class=o>::</span><span class=n>barrier</span><span class=o>&lt;</span><span class=n>cuda</span><span class=o>::</span><span class=n>thread_scope</span><span class=o>::</span><span class=n>thread_scope_block</span><span class=o>&gt;</span> <span class=n>backBarrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>frontBarrierPtr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>frontBarrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>backBarrierPtr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>backBarrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>block</span><span class=p>.</span><span class=n>thread_rank</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>frontBarrier</span><span class=p>,</span> <span class=n>block</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>backBarrier</span><span class=p>,</span> <span class=n>block</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>__syncthreads</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Introduce kTileDimK, so the tile is not square, otherwise it would be too large
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Here Ads is transposed
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Ads_T</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimY</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>__shared__</span> <span class=n>Value_t</span> <span class=n>Bds</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>kBlockTileDimK</span><span class=p>][</span><span class=n>kBlockWorkDimX</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>by</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>bx</span> <span class=o>=</span> <span class=n>blockIdx</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpSize</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>warpIdx</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>kWarpSize</span><span class=p>;</span>  <span class=c1>// the warp this thread is in
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>wy</span> <span class=o>=</span> <span class=n>warpIdx</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>wx</span> <span class=o>=</span> <span class=n>warpIdx</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=n>kWarpWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// thread&#39;s position w.r.t. warp tile (ACTUAL warp).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>threadIdxInWarp</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=n>kWarpSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>ty_in_acutal_warp</span> <span class=o>=</span> <span class=n>threadIdxInWarp</span> <span class=o>/</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>tx_in_acutal_warp</span> <span class=o>=</span> <span class=n>threadIdxInWarp</span> <span class=o>%</span> <span class=p>(</span><span class=n>kWarpTileWorkDimX</span> <span class=o>/</span> <span class=n>kThreadWorkDimX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Move tile to beginning of d_A&#39;s row and d_B&#39;s column
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_A</span> <span class=o>+=</span> <span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>*</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d_B</span> <span class=o>+=</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Here output position needs to go to warp output position
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_C</span> <span class=o>+=</span> <span class=p>(</span><span class=n>by</span> <span class=o>*</span> <span class=n>kBlockWorkDimY</span> <span class=o>+</span> <span class=n>wy</span> <span class=o>*</span> <span class=n>kWarpWorkDimY</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>bx</span> <span class=o>*</span> <span class=n>kBlockWorkDimX</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>         <span class=n>wx</span> <span class=o>*</span> <span class=n>kWarpWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Calculate the indices that this thread will load into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Ads_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_row</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>int</span> <span class=n>Bds_col</span> <span class=o>=</span> <span class=n>threadIdx</span><span class=p>.</span><span class=n>x</span> <span class=o>%</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>strideA</span> <span class=o>=</span> <span class=n>kThreadNumInBlock</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockTileDimK</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>strideB</span> <span class=o>=</span> <span class=n>kThreadNumInBlock</span> <span class=o>/</span> <span class=p>(</span><span class=n>kBlockWorkDimX</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileNumY</span> <span class=o>=</span> <span class=n>kWarpWorkDimY</span> <span class=o>/</span> <span class=n>kWarpTileWorkDimY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=kt>int</span> <span class=n>kWarpTileNumX</span> <span class=o>=</span> <span class=n>kWarpWorkDimX</span> <span class=o>/</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Register caches for Ads and Bds (on the warptile level)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>A_reg</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Value_t</span> <span class=n>B_reg</span><span class=p>[</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mf>0.0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Results are in register file in warp scheduler
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Value_t</span> <span class=n>c_value</span><span class=p>[</span><span class=n>kWarpTileNumY</span><span class=p>][</span><span class=n>kWarpTileNumX</span><span class=p>][</span><span class=n>kThreadWorkDimY</span><span class=p>][</span><span class=n>kThreadWorkDimX</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>curr_buffer_idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Double-buffering: load first blocktile into SMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LoadFromGmem</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>strideA</span><span class=p>,</span> <span class=n>strideB</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>Ads_T</span><span class=p>[</span><span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>Bds</span><span class=p>[</span><span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>Ads_col</span><span class=p>,</span> <span class=n>Ads_row</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>Bds_row</span><span class=p>,</span> <span class=n>Bds_col</span><span class=p>,</span> <span class=o>*</span><span class=n>frontBarrierPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Advance tile after loading GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_A</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span><span class=p>;</span>      <span class=c1>// move kTileDimK columns to right
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d_B</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>// move kTileDimK rows down
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=cm>/* k operations of multiply-add are divided into phases, each phase correspond to an
</span></span></span><span class=line><span class=cl><span class=cm>   * iteration of for-loop */</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>ph</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>ph</span> <span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>ceil</span><span class=p>((</span><span class=n>Value_t</span><span class=p>)</span><span class=n>k</span> <span class=o>/</span> <span class=n>kBlockTileDimK</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=o>++</span><span class=n>ph</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LoadFromGmem</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>strideA</span><span class=p>,</span> <span class=n>strideB</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>d_A</span><span class=p>,</span> <span class=n>d_B</span><span class=p>,</span> <span class=n>Ads_T</span><span class=p>[</span><span class=mi>1</span> <span class=o>-</span> <span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>Bds</span><span class=p>[</span><span class=mi>1</span> <span class=o>-</span> <span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>Ads_col</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>Ads_row</span><span class=p>,</span> <span class=n>Bds_row</span><span class=p>,</span> <span class=n>Bds_col</span><span class=p>,</span> <span class=o>*</span><span class=n>backBarrierPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Advance tile after loading GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_A</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span><span class=p>;</span>      <span class=c1>// move kTileDimK columns to right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d_B</span> <span class=o>+=</span> <span class=n>kBlockTileDimK</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>  <span class=c1>// move kTileDimK rows down
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished loading data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>frontBarrierPtr</span><span class=o>-&gt;</span><span class=n>arrive_and_wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ProcessFromSmem</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>kThreadWorkDimY</span><span class=p>,</span> <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>kWarpTileNumY</span><span class=p>,</span> <span class=n>kWarpTileNumX</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>Ads_T</span><span class=p>[</span><span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>Bds</span><span class=p>[</span><span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>A_reg</span><span class=p>,</span> <span class=n>B_reg</span><span class=p>,</span> <span class=n>c_value</span><span class=p>,</span> <span class=n>wy</span><span class=p>,</span> <span class=n>wx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>ty_in_acutal_warp</span><span class=p>,</span> <span class=n>tx_in_acutal_warp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Make sure all threads in block finished loading data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>backBarrierPtr</span><span class=o>-&gt;</span><span class=n>arrive_and_wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Exchange buffer indices and barriers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>curr_buffer_idx</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>curr_buffer_idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>frontBarrierPtr</span><span class=p>,</span> <span class=n>backBarrierPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Compute the last blocktile
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>frontBarrierPtr</span><span class=o>-&gt;</span><span class=n>arrive_and_wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>ProcessFromSmem</span><span class=o>&lt;</span><span class=n>kBlockWorkDimX</span><span class=p>,</span> <span class=n>kBlockWorkDimY</span><span class=p>,</span> <span class=n>kWarpWorkDimX</span><span class=p>,</span> <span class=n>kWarpWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>kWarpTileWorkDimX</span><span class=p>,</span> <span class=n>kWarpTileWorkDimY</span><span class=p>,</span> <span class=n>kThreadWorkDimX</span><span class=p>,</span> <span class=n>kThreadWorkDimY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>kBlockTileDimK</span><span class=p>,</span> <span class=n>kWarpTileNumY</span><span class=p>,</span> <span class=n>kWarpTileNumX</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>Ads_T</span><span class=p>[</span><span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>Bds</span><span class=p>[</span><span class=n>curr_buffer_idx</span><span class=p>],</span> <span class=n>A_reg</span><span class=p>,</span> <span class=n>B_reg</span><span class=p>,</span> <span class=n>c_value</span><span class=p>,</span> <span class=n>wy</span><span class=p>,</span> <span class=n>wx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>ty_in_acutal_warp</span><span class=p>,</span> <span class=n>tx_in_acutal_warp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Write results to GMEM
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_y</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumY</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>w_sub_x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>w_sub_x</span> <span class=o>&lt;</span> <span class=n>kWarpTileNumX</span><span class=p>;</span> <span class=o>++</span><span class=n>w_sub_x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// move C pointer to current warp subtile
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>Value_t</span><span class=o>*</span> <span class=n>d_C_interim</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>d_C</span> <span class=o>+</span> <span class=p>(</span><span class=n>w_sub_y</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimY</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=n>w_sub_x</span> <span class=o>*</span> <span class=n>kWarpTileWorkDimX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cy</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cy</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimY</span><span class=p>;</span> <span class=o>++</span><span class=n>cy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>cx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>cx</span> <span class=o>&lt;</span> <span class=n>kThreadWorkDimX</span><span class=p>;</span> <span class=n>cx</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>              <span class=o>&amp;</span><span class=n>C_interim</span><span class=p>(</span><span class=n>ty_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimY</span> <span class=o>+</span> <span class=n>cy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>tx_in_acutal_warp</span> <span class=o>*</span> <span class=n>kThreadWorkDimX</span> <span class=o>+</span> <span class=n>cx</span><span class=p>))[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>              <span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>float4</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c_value</span><span class=p>[</span><span class=n>w_sub_y</span><span class=p>][</span><span class=n>w_sub_x</span><span class=p>][</span><span class=n>cy</span><span class=p>][</span><span class=n>cx</span><span class=p>])[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们可以看到，最大的区别是，从 GMEM -> SMEM 这一部分是换成了 <code>memcpy_async()</code>，这样不会堵塞后面的执行，并且依靠 <code>cuda::barrier</code> 来执行同步。可以看到两块 shared memory 分别加载两块 GMEM，并依赖于不同的 barrier，这样可以让不同块的 shared memory 分别进行“读 GMEM”和“到 REG 计算”这两个过程。</p></section><footer class=article-footer></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/ptx/><div class=article-details><h2 class=article-title>在 CUDA 中使用 PTX</h2></div></a></article><article><a href=/p/tensor_core_ptx/><div class=article-details><h2 class=article-title>通过 MMA 使用 NVIDIA GPU 的 Tensor Core</h2></div></a></article><article><a href=/p/cuda_softmax_opt/><div class=article-details><h2 class=article-title>CUDA Softmax 优化</h2></div></a></article><article><a href=/p/cuda_bank_conflict/><div class=article-details><h2 class=article-title>CUDA Bank Conflict 的解决方法</h2></div></a></article><article><a href=/p/cuda_cooperative_groups/><div class=article-details><h2 class=article-title>《Cooperative Groups Flexible CUDA Thread Programming》笔记</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2025 吕超阳的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>